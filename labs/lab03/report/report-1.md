---
## Front matter
title: "Лабораторная работа № 2"
subtitle: "Операционные системы"
author: "Ильина Любовь Александровна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
name: russian
options:
- spelling=modern
- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Цель работы: 
- изучить идеологию и применение средств контроля версий; 
- освоить умения по работе с git. 

# Задание



# Выполнение лабораторной работы

1.  Создаем учётную запись на https://github.com – с логином lailjina и email: ilyina.lubov@gmail.com – 
(рис. @fig:001)

![Создана учетная запись на https://github.com](image/png1.png){#fig:001 width=70%}

2.Установим программное обеспечение после обновления $ yum makecache (рис. @fig:002) с помощью команд $ yum install epel-release (рис. @fig:003) и $ yum -y install gitflow (рис. @fig:004)

![Обновление базы makecache](image/png2.png){#fig:002}



![Установка epel-release](image/png3.png){#fig:003}



![Установка gitflow](image/png4.png){#fig:004}



3. Базовая настройка git (рис. @fig:006)

![Настройка git](image/png5.png){#fig:006}

4. Создаем ключ SSH с помощью $ ssh-keygen -t rsa -b 4096 (рис. @fig:006)

![Создание ключа SSH](image/png6.png){#fig:006}

5. Cоздаем SSH ключ по алгоритму ed25519 с помощью команды $ ssh-keygen -t ed2551 (рис. @fig:007)

![Создание ключа SSH по алгоритму ed25519](image/png7.png){#fig:007}

6. Генерируем ключ pgp с помощью команды $ gpg --gen-key (рис. @fig:008)

![Генерируем ключ pgp](image/png8.png){#fig:008}

6.1. Выбрали тип ключа: RSA and RSA (рис. @fig:009)

![Выбор типа RSA and RSA](image/png9.png){#fig:009}

6.2. Выбрали размер ключа 4096 (рис. @fig:010)  

![Выбор размера ключа 4096](image/png10.png){#fig:010}

6.3. Выбрали срок действия; значение по умолчанию — 0 (срок действия не истекает никогда) (рис. @fig:011) 

![Выбор срока действия ключа](image/png11.png){#fig:011}

6.4. Введем личную информацию, которую GPG запросит и которая сохранится в ключе (рис. @fig:012):  
– Имя (не менее 5 символов).  
– Адрес электронной почты (соответствует на GitHub).  

![Введем личную информацию владельца ключа](image/png12.png){#fig:012}

7. Генерируем отпечатка ключа PGP с помощью $ gpg --list-secret-keys --keyid-format LONG (рис. @fig:013)

![Генерация отпечатка ключа PGP](image/png13.png){#fig:013}

8. Получим ключ для загрузки на github c $ gpg --armor --export <PGP Fingerprint> (рис. @fig:014)

![Получение ключа для загрузки на github](image/png14.png){#fig:014}

9. Подгрузим ключ pgp на https://github.com/settings/keys (рис. @fig:015)

![Подгрузка ключа PGP на github.com](image/png15.png){#fig:015}

10. Используя введёный email, укажем Git применять его при подписи коммитов (рис. @fig:016)

![Настройка подписи коммитов](image/png16.png){#fig:016}

11. Создадим репозиторий курса на основе шаблона 

11.1. Сначала выгрузим SSH ключ с $ cat ~/.ssh/id_rsa.pub (рис. @fig:017) и загрузим на https://github.com/ (рис. @fig:018)

![Получение отпечатка SSH ключа для загрузки на github](image/png17.png){#fig:017} 

![Загрузка SSH ключа для загрузки на github](image/png18.png){#fig:018} 

11.2. Установим $ yum install git (рис. @fig:019)

![Установка git](image/png19.png){#fig:019} 

11.3. Создаем папки курса (рис. @fig:020) с помощью:
$ mkdir -p ~/work/study/2021-2022/"Операционные системы"   

$ cd ~/work/study/2021-2022/"Операционные системы"  

$ gh repo create study_2021-2022_os-intro --template=yamadharma/course-directory-student-template --public 

![Создание папки курса](image/png20.png){#fig:020} 

11.4. Клонируем репозиторий с созданием папки os-intro командой $ git clone --recursive git@github.com:lailjina/os-intro.git os-intro (рис. @fig:021)

![Клонируем репозиторий с созданием папки os-intro](image/png21.png){#fig:021} 

12. Настроим каталог курса (рис. @fig:022): заходим в директорию(cd os-intro), удаляем файлы ($ rm package.json) и создаем файлы (make COURSE=os-intro).

![Настройка каталога курса](image/png22.png){#fig:022}

13. Отправим файлы на сервер: $ git add -A. и задаем структуру курса $ git commit -am 'feat(main): make course structure' (рис. @fig:023)

![Отправка файлов на сервер и настройка структуры курса](image/png23.png){#fig:023}

14. Изменения синхронизируем с репозиторием гитхаб с помощью git push(рис. @fig:024)

![Синхронизация с репозиторием гитхаб](image/png24.png){#fig:024}


# Выводы

Вывод: Мной изучена идеология и применение средств контроля версий, а также приобретены навык работы с git. 

Ответы на контрольные вопросы: 

1. Что такое системы контроля версий (VCS) и для решения каких задач они предназначаются?  

Системы контроля версий (Version Control System, VCS) применяются при работе нескольких человек над одним проектом. 

2. Объясните следующие понятия VCS и их отношения: хранилище, commit, история, рабочая копия.  

Хранилище (repository), или репозитарий, — место хранения файлов и их версий, служебной информации. 

Хранилище (repository), или репозитарий, — место хранения файлов и их версий, служебной информации. 

История - состояние всего хранилища или отдельных файлов в момент времени. 

Рабочая копия (working copy) — текущее состояние файлов проекта (любой версии), полученных из хранилища и, возможно, измененных. 

3. Что представляют собой и чем отличаются централизованные и децентрализованные VCS? Приведите примеры VCS каждого вида. 

В централизованных СКВ все файлы хранятся в одном репозитории, и каждый пользователь может вносить изменения. В децентрализованных их несколько, и они могут обмениваться изменениями между собой, а центрального репозитория может не существовать вообще. Среди классических (т.е. централизованных) VCS наиболее известны CVS, Subversion, а среди распределённых — Git, Bazaar, Mercurial. 

4. Опишите действия с VCS при единоличной работе с хранилищем.  

Получить нужную версию проекта (рабочую копию), внести в неё необходимые изменения, сделать нужный коммит, создав при этом новую версию проекта (старые не удаляются). 

5. Опишите порядок работы с общим хранилищем VCS.  

Аналогично единоличной работе, но также можно объединить внесённые разными пользователями изменения, отменить изменения или заблокировать некоторые файлы для изменения, обеспечив привилегированный доступ конкретному разработчику.	 

6. Каковы основные задачи, решаемые инструментальным средством git?  

Система контроля версий Git представляет собой набор программ командной строки. Доступ к ним можно получить из терминала посредством ввода команды git с различными опциями. Git позволяет создавать локальные репозитории и вносить в них изменения, а также работать с удалёнными репозиториями. 

7. Назовите и дайте краткую характеристику командам git.  

git. 1)создание основного дерева репозитория:  

git init 2)получение обновлений (изменений) текущего дерева из центрального репозитория: git pull 3)отправка всех произведённых изменений локального дерева в центральный репозиторий: git push 4)просмотр списка изменённых файлов в текущей директории: git status 5)просмотр текущих изменения: git diff 6)сохранение текущих изменений: а)добавить все изменённые и/или созданные файлы и/или каталоги: git add . б)добавить конкретные изменённые и/или созданные файлы и/или каталоги: git add имена_файлов в)удалить файл и/или каталог из индекса репозитория (при этом файл и/или каталог остаётся в локальной директории): git rm имена_файлов 7)сохранение добавленных изменений: а)сохранить все добавленные изменения и все изменённые файлы: git commit -am 'Описание коммита' б)сохранить добавленные изменения с внесением комментария через встроенный редактор: git commit 8)создание новой ветки, базирующейся на текущей: git checkout -b имя_ветки 9)переключение на некоторую ветку: git checkout имя_ветки (при переключении на ветку, которой ещё нет в локальном репозитории, она будет создана и связана с удалённой) 10)отправка изменений конкретной ветки в центральный репозиторий: git push origin имя_ветки 11)слияние ветки с текущим деревом: git merge --no-ff имя_ветки 12)удаление ветки: а)удаление локальной уже слитой с основным деревом ветки: git branch -d имя_ветки б)принудительное удаление локальной ветки: git branch -D имя_ветки в)удаление ветки с центрального репозитория: git push origin :имя_ветки 

8. Приведите примеры использования при работе с локальным и удалённым репозиториями.  

Допустим, нужно добавить в проект новый файл file.txt Загрузим нужную версию из удалённого репозитория: git checkout last (last – имя нужной нам ветки) Добавим файл в локальный репозиторий: git add file.txt (файл лежит в том же каталоге, что и репозиторий) Сохраним изменения: git commit –am “file.txt was added” Отправим изменения в удалённый репозиторий: git push 

9. Что такое и зачем могут быть нужны ветви (branches)?  

Допустим, нужно добавить в проект новый файл file.txt Загрузим нужную версию из удалённого репозитория: git checkout last (last – имя нужной нам ветки) Добавим файл в локальный репозиторий: git add file.txt (файл лежит в том же каталоге, что и репозиторий) Сохраним изменения: git commit –am “file.txt was added” Отправим изменения в удалённый репозиторий: git push 

10. Как и зачем можно игнорировать некоторые файлы при commit 

Допустим, нужно добавить в проект новый файл file.txt Загрузим нужную версию из удалённого репозитория: git checkout last (last – имя нужной нам ветки) Добавим файл в локальный репозиторий: git add file.txt (файл лежит в том же каталоге, что и репозиторий) Сохраним изменения: git commit –am “file.txt was added” Отправим изменения в удалённый репозиторий: git push 


